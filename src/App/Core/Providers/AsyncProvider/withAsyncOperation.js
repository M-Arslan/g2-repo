import React from 'react';
import {
    Spinner
} from '../../Forms/Common';
import { ensureNonEmptyString, ensureNonNullObject } from '../../Utility/rules';
import {
    GraphOperation,
    useGraphQL
} from '../GraphQL';
import {
    NOOP
} from '../GraphQL/GraphOperation';

/*************************************************************************************
 * USAGE EXAMPLE
 * 
 * const ChildComponent = ({ asyncResult, requestSave, requestRefresh }) => {
 *  return <span>{`Hello, ${asyncResult}!`}</span>;
 * };
 * 
 * const ParentComponent = () => {
 *  const loadName = () => Promise.resolve('World');
 *  const ChildHOC = withAsyncOperation(ChildComponent, LoadName, SaveName);
 *  return <div><ChildHOC context={{ id: 1 }} /></div>
 * };
 * 
 *************************************************************************************/

/**
 * withAsyncOperation executes an async operation and holds the UI displaying only after completion.  This creates 
 * a Higher Order Component.  Injects result of the operation as prop 'asyncResult' to wrapped component.
 * 
 * @param {React.Component} Component - component to render
 * @param {GraphOperation} getOperation - operation to await for data population
 * @param {GraphOperation} saveOperation - operation to handle a save request
 * @returns {React.Component}
 */
export function withAsyncOperation(Component, getOperation, saveOperation, operations = {}) {

    return ({ context, ...rest }) => {
        const [loading, setLoading] = React.useState(false);
        const [result, setResult] = React.useState(null);

        const $api = useGraphQL({
            ...operations,
            _get: (getOperation || NOOP),
            _save: (saveOperation || NOOP)
        });

        const reloadResults = async () => {
            try {
                setLoading(true);
                $api._get(context).then(res => {
                    setResult(res);
                    setLoading(false);
                }, err => {
                    console.error('[withAsyncOperation::HOC::reloadResults] error in HOC generated by withAsyncOperation', err);
                });
            }
            catch (ex) {
                throw ex;
            }
            finally {
                if (loading === true) {
                    setLoading(false);
                }
            }
        };

        React.useEffect(() => {
            if (ensureNonNullObject(context)) {
                reloadResults();
            }
        }, [context]);

        const dispatch = (action) => {
            if (ensureNonNullObject(action) !== true) {
                throw new Error('[withAsyncOperation] dispatch expects argument "action" to be a non-null object');
            }

            if (ensureNonEmptyString(action.type) !== true) {
                throw new Error(`[withAsyncOperation] dispatch expects argument "action" to a have a property "type" which is a non-empty string`);
            }

            if (action.type === '_get') {
                reloadResults();
            }
            else if (typeof $api[action.type] === 'function') {
                const args = (ensureNonNullObject(action.args) ? action.args : {});
                $api[action.type](args).then((result) => {
                    if (action.reload !== false) {
                        reloadResults();
                    }
                });

            }
        }

        const saveRequest = async (request, silent = true, refresh = false) => {

            const quietMode = (silent !== false);

            if (!quietMode) {
                setLoading(true);
            }

            try {
                const res = await $api._save(request);

                if (refresh === true) {
                    setResult(res);
                }

                if (!quietMode) {
                    reloadResults();
                }

                return res;
            }
            catch (ex) {
                throw ex;
            }
            finally {
                if (loading === true) {
                    setLoading(false);
                }
            }
        };

        return (loading === true ? <Spinner /> : <Component asyncResult={result} dispatch={dispatch} requestSave={saveRequest} requestRefresh={reloadResults} {...rest} />);
    }
}

/**
 * Temporary Fix for a larger refactor
 * @param {function} fn
 */
export const WrapFunctionAsOperation = (fn) => class GqlWrapper extends GraphOperation {
    constructor() {
        super('', '');
        this._fn = fn;
    }

    async execute(ctx) {
        return await this._fn(ctx);
    }
};